"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listFrameworksConnections = exports.getOrCreateRepository = exports.getOrCreateConnection = exports.createConnection = exports.linkGitHubRepository = exports.parseConnectionName = void 0;
const clc = require("colorette");
const gcb = require("../../../gcp/cloudbuild");
const poller = require("../../../operation-poller");
const utils = require("../../../utils");
const api_1 = require("../../../api");
const error_1 = require("../../../error");
const logger_1 = require("../../../logger");
const prompt_1 = require("../../../prompt");
const FRAMEWORKS_CONN_PATTERN = /.+\/frameworks-github-conn-.+$/;
const FRAMEWORKS_OAUTH_CONN_NAME = "frameworks-github-oauth";
const CONNECTION_NAME_REGEX = /^projects\/(?<projectId>[^\/]+)\/locations\/(?<location>[^\/]+)\/connections\/(?<id>[^\/]+)$/;
function parseConnectionName(name) {
    const match = name.match(CONNECTION_NAME_REGEX);
    if (!match || typeof match.groups === undefined) {
        return;
    }
    const { projectId, location, id } = match.groups;
    return {
        projectId,
        location,
        id,
    };
}
exports.parseConnectionName = parseConnectionName;
const gcbPollerOptions = {
    apiOrigin: api_1.cloudbuildOrigin,
    apiVersion: "v2",
    masterTimeout: 25 * 60 * 1000,
    maxBackoff: 10000,
};
function extractRepoSlugFromUri(remoteUri) {
    const match = /github.com\/(.+).git/.exec(remoteUri);
    if (!match) {
        return undefined;
    }
    return match[1];
}
function generateRepositoryId(remoteUri) {
    var _a;
    return (_a = extractRepoSlugFromUri(remoteUri)) === null || _a === void 0 ? void 0 : _a.replaceAll("/", "-");
}
function generateConnectionId() {
    const randomHash = Math.random().toString(36).slice(6);
    return `frameworks-github-conn-${randomHash}`;
}
async function linkGitHubRepository(projectId, location) {
    var _a, _b, _c;
    logger_1.logger.info(clc.bold(`\n${clc.yellow("===")} Connect a GitHub repository`));
    const existingConns = await listFrameworksConnections(projectId);
    if (existingConns.length < 1) {
        let oauthConn = await getOrCreateConnection(projectId, location, FRAMEWORKS_OAUTH_CONN_NAME);
        while (oauthConn.installationState.stage === "PENDING_USER_OAUTH") {
            oauthConn = await promptConnectionAuth(oauthConn);
        }
        const connectionId = generateConnectionId();
        const conn = await createConnection(projectId, location, connectionId, {
            authorizerCredential: (_a = oauthConn.githubConfig) === null || _a === void 0 ? void 0 : _a.authorizerCredential,
        });
        let refreshedConn = conn;
        while (refreshedConn.installationState.stage !== "COMPLETE") {
            refreshedConn = await promptAppInstall(conn);
        }
        existingConns.push(refreshedConn);
    }
    let { remoteUri, connection } = await promptRepositoryUri(projectId, location, existingConns);
    while (remoteUri === "") {
        await utils.openInBrowser("https://github.com/apps/google-cloud-build/installations/new");
        await (0, prompt_1.promptOnce)({
            type: "input",
            message: "Press ENTER once you have finished configuring your installation's access settings.",
        });
        const selection = await promptRepositoryUri(projectId, location, existingConns);
        remoteUri = selection.remoteUri;
        connection = selection.connection;
    }
    const { id: connectionId } = parseConnectionName(connection.name);
    await getOrCreateConnection(projectId, location, connectionId, {
        authorizerCredential: (_b = connection.githubConfig) === null || _b === void 0 ? void 0 : _b.authorizerCredential,
        appInstallationId: (_c = connection.githubConfig) === null || _c === void 0 ? void 0 : _c.appInstallationId,
    });
    const repo = await getOrCreateRepository(projectId, location, connectionId, remoteUri);
    logger_1.logger.info();
    utils.logSuccess(`Successfully linked GitHub repository at remote URI:\n ${remoteUri}`);
    return repo;
}
exports.linkGitHubRepository = linkGitHubRepository;
async function promptRepositoryUri(projectId, location, connections) {
    const remoteUriToConnection = {};
    for (const conn of connections) {
        const { id } = parseConnectionName(conn.name);
        const resp = await gcb.fetchLinkableRepositories(projectId, location, id);
        if (resp.repositories && resp.repositories.length > 1) {
            for (const repo of resp.repositories) {
                remoteUriToConnection[repo.remoteUri] = conn;
            }
        }
    }
    const choices = Object.keys(remoteUriToConnection).map((remoteUri) => ({
        name: extractRepoSlugFromUri(remoteUri) || remoteUri,
        value: remoteUri,
    }));
    choices.push({
        name: "Missing a repo? Select this option to configure your installation's access settings",
        value: "",
    });
    const remoteUri = await (0, prompt_1.promptOnce)({
        type: "list",
        message: "Which of the following repositories would you like to deploy?",
        choices,
    });
    return { remoteUri, connection: remoteUriToConnection[remoteUri] };
}
async function promptConnectionAuth(conn) {
    logger_1.logger.info("You must authorize the Cloud Build GitHub app.");
    logger_1.logger.info();
    logger_1.logger.info("First, sign in to GitHub and authorize Cloud Build GitHub app:");
    const cleanup = await utils.openInBrowserPopup(conn.installationState.actionUri, "Authorize the GitHub app");
    await (0, prompt_1.promptOnce)({
        type: "input",
        message: "Press Enter once you have authorized the app",
    });
    cleanup();
    const { projectId, location, id } = parseConnectionName(conn.name);
    return await gcb.getConnection(projectId, location, id);
}
async function promptAppInstall(conn) {
    logger_1.logger.info("Now, install the Cloud Build GitHub app:");
    const targetUri = conn.installationState.actionUri.replace("install_v2", "direct_install_v2");
    logger_1.logger.info(targetUri);
    await utils.openInBrowser(targetUri);
    await (0, prompt_1.promptOnce)({
        type: "input",
        message: "Press Enter once you have installed or configured the Cloud Build GitHub app to access your GitHub repo.",
    });
    const { projectId, location, id } = parseConnectionName(conn.name);
    return await gcb.getConnection(projectId, location, id);
}
async function createConnection(projectId, location, connectionId, githubConfig) {
    const op = await gcb.createConnection(projectId, location, connectionId, githubConfig);
    const conn = await poller.pollOperation(Object.assign(Object.assign({}, gcbPollerOptions), { pollerName: `create-${location}-${connectionId}`, operationResourceName: op.name }));
    return conn;
}
exports.createConnection = createConnection;
async function getOrCreateConnection(projectId, location, connectionId, githubConfig) {
    let conn;
    try {
        conn = await gcb.getConnection(projectId, location, connectionId);
    }
    catch (err) {
        if (err.status === 404) {
            conn = await createConnection(projectId, location, connectionId, githubConfig);
        }
        else {
            throw err;
        }
    }
    return conn;
}
exports.getOrCreateConnection = getOrCreateConnection;
async function getOrCreateRepository(projectId, location, connectionId, remoteUri) {
    const repositoryId = generateRepositoryId(remoteUri);
    if (!repositoryId) {
        throw new error_1.FirebaseError(`Failed to generate repositoryId for URI "${remoteUri}".`);
    }
    let repo;
    try {
        repo = await gcb.getRepository(projectId, location, connectionId, repositoryId);
        const repoSlug = extractRepoSlugFromUri(repo.remoteUri);
        if (repoSlug) {
            throw new error_1.FirebaseError(`${repoSlug} has already been linked.`);
        }
    }
    catch (err) {
        if (err.status === 404) {
            const op = await gcb.createRepository(projectId, location, connectionId, repositoryId, remoteUri);
            repo = await poller.pollOperation(Object.assign(Object.assign({}, gcbPollerOptions), { pollerName: `create-${location}-${connectionId}-${repositoryId}`, operationResourceName: op.name }));
        }
        else {
            throw err;
        }
    }
    return repo;
}
exports.getOrCreateRepository = getOrCreateRepository;
async function listFrameworksConnections(projectId) {
    const conns = await gcb.listConnections(projectId, "-");
    return conns.filter((conn) => FRAMEWORKS_CONN_PATTERN.test(conn.name) &&
        conn.installationState.stage === "COMPLETE" &&
        !conn.disabled);
}
exports.listFrameworksConnections = listFrameworksConnections;
